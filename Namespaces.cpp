/* 3 types of namespaces possible - global,local or specific to one namespace
3 types of declaration possible - no namespace defined, no namespace and no scope resolution defined, both are defined
If no namespace and no scope resolution is defined - takes local one, if local one does not exist - gives error
If only scope resolution give but no namespace defined - looks for global namespace then it looks for
included namespace then it looks for included header files namespaces*/


    // Namespace declarations appear only at global scope.
    // Namespace declarations can be nested within another namespace.
    // Namespace declarations donâ€™t have access specifiers. (Public or private)
    // No need to give semicolon after the closing brace of definition of namespace.
    // We can split the definition of namespace over several units.

    //  Unnamed Namespaces :

    // They are directly usable in the same program and are used for declaring unique identifiers.
    // In unnamed namespaces, name of the namespace in not mentioned in the declaration of namespace.
    // The name of the namespace is uniquely generated by the compiler.
    // The unnamed namespaces you have created will only be accessible within the file you created it in.
    // Unnamed namespaces are the replacement for the static declaration of variables.

    // Extending namespaces (Using same name twice) :

    // It is also possible to create two namespace blocks having the same name. 
    // The second namespace block is nothing but actually the continuation of the first namespace. 
    // In simpler words, we can say that both the namespaces are not different but actually the same, which are being defined in parts.

    // Namespace aliasing:
    // In C++, you can use an alias name for your namespace name, for ease of use. 
    //Existing namespaces can be aliased with new names, with the following syntax:

    // namespace new_name = current_name;

    //Inline namespace : - Use case : to ensure backward compatibility in libraries

    //https://www.geeksforgeeks.org/inline-namespaces-usage-using-directive-inside-namespaces/

#include <iostream>

int a = -10;

namespace hello
{
    int a = 20;
}

namespace hello
{
    namespace hai
    {
        int b = a;
    }
}

using namespace hello;

int main()
{
    int a = 100;
    std::cout<<"local a is "<<a<<std::endl;
    std::cout<<"global a is "<<::a<<std::endl;
    std::cout<<"hello namespace a is "<<hello::a<<std::endl;
    std::cout<<"nested namespace b is "<<hello::hai::b<<std::endl;
}



